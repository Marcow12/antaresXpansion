---
title: "Expansion planning report"
output: html_document
---

This file has been generated by the package antaresXpansion.
It gives an overview of the results of the investment optimisation problem solved by the package.


```{r, include = FALSE}
## load packages
library(plotly)
library(magrittr)
library(dplyr)
library(data.table)
library(knitr)
library(shiny)
```

# General information


Studies considered for each simulated year:
```{r print_study_name, echo=FALSE, eval=TRUE}
for(id_years in 1:studies$n_simulated_years){
  cat(studies$simulated_years[[id_years]]," : ",studies$opts[[id_years]]$studyPath)
  if(id_years!=studies$n_simulated_years)
  {cat("\n")}
}
```

Date :
```{r print_date, echo=FALSE, eval=TRUE}
lubridate::now()
```

Expansion planning options :
```{r print_exp_options, echo=FALSE, eval=TRUE}
option_names <- names(x$expansion_options)
#option_names <- names(read_options(paste0(directory_path,"/settings.ini")))
for(i in 1:length(option_names))
{
  cat("   - ", option_names[i], " : ", x$expansion_options[[i]], "\n")
}

```

Package version :
```{r print_package_version, echo=FALSE, eval=TRUE}
packageVersion("antaresXpansion")
```

# Best found solution
```{r get_best_cost, echo = FALSE, eval = TRUE}
# <!-- best_solutions <- which(x$costs$overall == min(x$costs$overall, na.rm = TRUE)) -->
# <!-- sol_id <- paste0("it", best_solutions) -->
# <!-- n_best_solution <- length(best_solutions) -->
n_iteration <- current_it$n -1 #-1 because current_it$n is incremented when reaching the end of the last iteration
```

Total cost : 
```{r print_total_cost, echo=FALSE, eval = TRUE}
{
cat(sum(unlist(subset(x$costs,it==best_solution)$overall)), "euros\n")
cat(sum(unlist(subset(x$costs,it==best_solution)$overall))/10^6, "million euros\n")
}
# if(n_best_solution > 1)
# {
#    cat("There is", n_best_solution, "equivalent solutions leading to this cost")
# }
```

Investment cost :
```{r print_inv_cost, echo=FALSE, eval = TRUE}
#we assume only a unique solution is possible (to be changed, display other solutions if they do exist)
#if(n_best_solution == 1)
{
  cat(sum(unlist(subset(x$costs,it==best_solution)$investment)), "euros\n")
  cat(sum(unlist(subset(x$costs,it==best_solution)$investment))/10^6, "million euros\n")
}
# if(n_best_solution > 1)
# {
# }

```

Production cost :
```{r print_prod_cost, echo=FALSE, eval = TRUE}
# if(n_best_solution == 1)
{
  cat(sum(unlist(subset(x$costs,it==best_solution)$operation)), "euros\n")
  cat(sum(unlist(subset(x$costs,it==best_solution)$operation))/10^6, "million euros\n")
}
# if(n_best_solution > 1)
# {
  #for(i in 1:n_best_solution)
  #{
  #}
# }
```


Invested capacities (in MW):
```{r print_invested_cap, echo=FALSE, eval = TRUE, results="asis"}
cat(" \n")
tmp<-list()
for (id_years in 1:studies$n_simulated_years)
{
  #yet to remove the first column giving just the row number
  tmp[[id_years]]<-kable(subset(subset(x$invested_capacities,it==best_solution & s_years == studies$simulated_years[[id_years]]),select=c(candidate,value)), format = "markdown", row.names=NA)
}
names(tmp)<-sapply(1:studies$n_simulated_years,FUN=function(id_years){paste0("year ",studies$simulated_years[id_years])})
tmp
```


# Convergence

Number of iterations :
```{r print_number_of_iterations, echo=FALSE, eval = TRUE}
cat(n_iteration)
```

Number of simulated weeks :
```{r print_number_of_simulated_weeks, echo=FALSE, eval = TRUE}

n_weeks <- sum(sapply(1:n_iteration, FUN = function(i){length(x$iterations[[i]]$weeks) * length(x$iterations[[i]]$mc_years)}))
#not sure if there is a mistake here, maybe no length in length(x$iterations[[i]]$mc_years)? must try with more mc_years
cat(n_weeks)
```


<!-- Iteration with the (last) best solution : -->
<!-- ```{r print_iteration_best, echo=FALSE, eval = TRUE} -->
<!-- cat(best_solution) -->
<!-- ``` -->

Optimality gap - Distance between greatest lower bound and best solution -  equal to zero when optimal solution has been reached:
(When UC mode is fast or accurate, this gap can be negative due to the approximations of ANTARES' heuristics. When relaxed UC mode are used, this gap can be slightly negative due to numeric approximations in cuts)
```{r print_optimality_gap, echo=FALSE, eval = TRUE}
{
cat( sum(unlist(as.numeric(subset(x$costs,it==best_solution)$overall))) - max(unlist(x$under_estimator)), "euros \n")
cat("best under estimator: ", max(unlist(x$under_estimator))," \n")
cat("value of the objective function: (sum of the overall costs on the simulated years) ", sum(unlist(as.numeric(subset(x$costs,it==best_solution)$overall))))
}
```

Convergence of costs
```{r plot_cost_convergence, echo = FALSE, eval = TRUE, warning = FALSE, message=FALSE}

# prepare data.frame structure for plotly
costs <- data.frame(iteration = 1:n_iteration)

costs$investment_costs <- sapply(1:n_iteration,FUN=function(iteration){append(costs$investment_costs,sum(unlist(as.numeric(subset(x$costs,it==iteration)$investment))))})

costs$operation_costs <- sapply(1:n_iteration,FUN=function(iteration){append(costs$operation_costs,sum(unlist(as.numeric(subset(x$costs,it==iteration)$operation)),na.rm = TRUE))})

costs$overall_costs <- sapply(1:n_iteration,FUN=function(iteration){append(costs$overall_costs,sum(unlist(as.numeric(subset(x$costs,it==iteration)$overall))))})

#costs$best_bound  <-  max(unlist(x$under_estimator)) ?? create costs as a list?

min_1_n <- function(n, vect)
{
  if(!all(is.na(vect[1:n])))
  {
    return(min(vect[1:n], na.rm = TRUE))
  }
  else{return(NA)}
}

# costs$best_solution_until_now <- sapply(1:n_iteration, min_1_n, vect = sum(unlist(as.numeric(subset(x$costs,it==iteration)$overall))))
#
# # plot (ov_cost, best_bound, best_sol) = f(it)
#
# p <- plot_ly(costs, x = ~iteration, width = "100%") %>%
#   add_trace(y = ~best_solution_until_now, name = 'Best solution until this iteration', mode = 'lines+markers', type = "scatter") %>%
#   add_trace(y = ~best_bound, name = 'Lower bound', mode = 'lines+markers', type = "scatter") %>%
#   add_trace(x = ~iteration[!is.na(overall_costs)], y = ~na.omit(overall_costs), name = 'Total cost',mode = 'lines+markers', type = "scatter") %>%
#   layout(yaxis = list(title = "(euros)"), legend = list(orientation = 'h'))
#
# p

```



# Details for each iteration

Table - invested capacity at each iteration (in MW) :

```{r table_details, echo = FALSE}


# <!-- # transpose -->
# <!-- capa_table <- as.data.frame(t(x$invested_capacities)) -->
# <!-- rownames(capa_table) <- paste0("it", 1:n_iteration) -->
# <!-- colnames(capa_table) <- rownames(x$invested_capacities) -->
#
kable(x$invested_capacities, format = "markdown")


```

Table - costs for each iteration (in euros) :

```{r table_costs, echo = FALSE}

# costs_table <- costs[c("overall_costs", "investment_costs", "operation_costs")]
# rownames(costs_table) <- paste0("it", 1:n_iteration)
# costs_table <- costs_table

kable(x$costs, format = "markdown")

```

Table - Loss of Load Expectation(in hours) :

```{r table_lole, echo = FALSE}

kable(x$digest, format = "markdown")

```

<style type="text/css">
.table {

    width: 40%;

}
</style>